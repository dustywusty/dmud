=== internal/net/server.go ===
package net

import (
	"context"
	"fmt"
	"net"
	"net/http"
	"sync"

	"dmud/internal/common"
	"dmud/internal/game"

	"github.com/rs/zerolog/log"
)

type ServerConfig struct {
	TCPHost string
	TCPPort string

	WSHost string
	WSPort string
}

type Server struct {
	connectionMu sync.Mutex
	connections  map[string]common.Client

	game *game.Game

	tcpListener net.Listener
	tcpHost     string
	tcpPort     string

	wsServer *http.Server
	wsHost   string
	wsPort   string
}

func (s *Server) Run() {
	var wg sync.WaitGroup
	wg.Add(2)

	s.game = game.NewGame()

	if s.tcpHost != "" && s.tcpPort != "" {
		go func() {
			s.runTCPListener()
			wg.Done()
		}()
	}

	if s.wsHost != "" && s.wsPort != "" {
		go func() {
			s.runWebSocketServer()
			wg.Done()
		}()
	}

	wg.Wait()
}

func (s *Server) Shutdown() {
	s.connectionMu.Lock()
	for _, client := range s.connections {
		client.CloseConnection()
	}
	s.connectionMu.Unlock()

	if s.tcpListener != nil {
		if err := s.tcpListener.Close(); err != nil {
			log.Error().Err(err).Msg("Failed to close TCP listener")
		} else {
			log.Info().Msg("TCP listener successfully closed")
		}
	}

	if s.wsServer != nil {
		if err := s.wsServer.Shutdown(context.Background()); err != nil {
			log.Error().Err(err).Msg("Failed to shutdown HTTP server")
		} else {
			log.Info().Msg("WebSocket server successfully shut down")
		}
	}
}

func (s *Server) runTCPListener() {
	listener, err := net.Listen("tcp", fmt.Sprintf("%s:%s", s.tcpHost, s.tcpPort))
	if err != nil {
		log.Error().Err(err).Msg("")
		return
	}
	s.tcpListener = listener

	log.Info().Msgf("Listening TCP on %s:%s", s.tcpHost, s.tcpPort)

	done := make(chan bool)
	go func() {
		for {
			conn, err := listener.Accept()
			if err != nil {
				if opErr, ok := err.(*net.OpError); ok && opErr.Op == "accept" {
					log.Info().Msg("TCP listener stopped")
				} else {
					log.Error().Err(err).Msg("")
				}
				done <- true
				return
			}

			remoteAddr := conn.RemoteAddr().String()
			log.Info().Msgf("Accepted TCP connection from %s", remoteAddr)

			client := &TCPClient{
				conn: conn,
				game: s.game,
			}

			s.connectionMu.Lock()
			s.connections[remoteAddr] = client
			s.connectionMu.Unlock()

			s.game.AddPlayerChan <- client
		}
	}()

	<-done
}

func (s *Server) runWebSocketServer() {
	done := make(chan bool)

	s.wsServer = &http.Server{
		Addr: fmt.Sprintf("%s:%s", s.wsHost, s.wsPort),
		Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			conn, err := upgrader.Upgrade(w, r, nil)
			if err != nil {
				log.Error().Err(err).Msg("Failed to set websocket upgrade")
				return
			}

			remoteAddr := conn.RemoteAddr().String()

			log.Info().Msgf("Accepted WebSocket connection from %s", remoteAddr)

			client := &WSClient{
				conn:   conn,
				status: common.Connected,
				game:   s.game,
			}

			s.connectionMu.Lock()
			s.connections[remoteAddr] = client
			s.connectionMu.Unlock()

			s.game.AddPlayerChan <- client
		}),
	}

	log.Info().Msgf("Listening WebSocket on %s:%s", s.wsHost, s.wsPort)

	go func() {
		err := s.wsServer.ListenAndServe()
		if err != http.ErrServerClosed {
			log.Fatal().Err(err).Msg("Failed to start WebSocket server")
		} else {
			log.Info().Msg("WebSocket server stopped")
		}
		done <- true
	}()

	<-done
}

func NewServer(config *ServerConfig) *Server {
	return &Server{
		tcpHost:     config.TCPHost,
		tcpPort:     config.TCPPort,
		wsHost:      config.WSHost,
		wsPort:      config.WSPort,
		connections: make(map[string]common.Client),
	}
}
=== internal/net/ws_client.go ===
package net

import (
	"net/http"
	"net/url"
	"regexp"
	"strings"
	"sync"

	"dmud/internal/common"
	"dmud/internal/game"
	"dmud/internal/util"

	"github.com/gorilla/websocket"
	"github.com/rs/zerolog/log"
)

var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool {
		origin := r.Header.Get("Origin")
		parsedOrigin, err := url.Parse(origin)
		if err != nil {
			log.Error().Err(err).Msg("Error parsing Origin header")
			return false
		}

		if strings.ToLower(parsedOrigin.Hostname()) != "localhost" {
			log.Info().Msgf("Origin %s is not localhost", parsedOrigin.Hostname())
			return false
		}

		return true
	},
}

type WSClient struct {
	status common.ConnectionStatus
	conn   *websocket.Conn
	game   *game.Game
	mu     sync.Mutex
}

var _ common.Client = (*WSClient)(nil)

func (c *WSClient) CloseConnection() error {
	c.mu.Lock()
	defer c.mu.Unlock()

	c.status = common.Disconnecting

	log.Info().Msgf("Trying to close connection to %s", c.RemoteAddr())

	if c.conn.UnderlyingConn() == nil {
		log.Info().Msgf("Connection to %s already closed", c.RemoteAddr())
		return nil
	}
	err := c.conn.Close()
	if err != nil {
		log.Error().Err(err).Msg("Error closing connection")
		return err
	}

	c.status = common.Disconnected

	log.Info().Msgf("Closed connection to %s", c.RemoteAddr())
	return nil
}

func (c *WSClient) HandleRequest() {
	g := c.game
	slurRegexes := compileSlurRegexes()

	for {
		messageType, p, err := c.readMessage()
		if err != nil {
			handleReadError(err, c)
			return
		}

		if containsSlur(slurRegexes, p) {
			log.Warn().Msgf("Slur detected in message from %s. Message rejected.", c.RemoteAddr())
			g.RemovePlayerChan <- c
			return
		}

		if messageType == websocket.TextMessage {
			processTextMessage(p, c)
		} else {
			log.Warn().Msgf("Unknown message type %d from %s", messageType, c.RemoteAddr())
		}
	}
}

func (c *WSClient) RemoteAddr() string {
	return c.conn.RemoteAddr().String()
}

func (c *WSClient) SendMessage(msg string) {
	err := c.conn.WriteMessage(websocket.TextMessage, []byte(msg))
	if err != nil {
		log.Error().Msgf("Error sending message %s to %s: %s", msg, c.RemoteAddr(), err)
	} else {
		log.Trace().Msgf("Sent message to %s:\n%s", c.RemoteAddr(), msg)
	}
}

func containsSlur(slurRegexes []*regexp.Regexp, message []byte) bool {
	inputLower := strings.ToLower(strings.TrimSpace(string(message)))
	for _, re := range slurRegexes {
		if re.MatchString(inputLower) {
			return true
		}
	}
	return false
}

func compileSlurRegexes() []*regexp.Regexp {
	var slurRegexes []*regexp.Regexp
	for _, slur := range util.Slurs {
		re, err := regexp.Compile(`\b` + regexp.QuoteMeta(slur) + `\b`)
		if err != nil {
			log.Error().Msgf("Error compiling regex: %s", err)
			continue
		}
		slurRegexes = append(slurRegexes, re)
	}
	return slurRegexes
}

func handleReadError(err error, c *WSClient) {
	g := c.game
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.status == common.Disconnected {
		return
	}
	c.status = common.Disconnected
	log.Error().Err(err).Msgf("Error reading message from %s", c.RemoteAddr())
	g.RemovePlayerChan <- c
}

func processTextMessage(p []byte, c *WSClient) {
	g := c.game
	log.Trace().Msgf("Received message from %s: %s", c.RemoteAddr(), p)
	parts := strings.SplitN(strings.TrimSpace(string(p)), " ", 2)
	cmd := parts[0]
	var args []string
	if len(parts) > 1 {
		args = strings.Split(parts[1], " ")
	}
	command := game.Command{
		Cmd:  cmd,
		Args: args,
	}
	clientCommand := game.ClientCommand{
		Command: command,
		Client:  c,
	}
	g.ExecuteCommandChan <- clientCommand
}

func (c *WSClient) readMessage() (messageType int, p []byte, err error) {
	messageType, p, err = c.conn.ReadMessage()
	if err != nil {
		c.mu.Lock()
		defer c.mu.Unlock()
		if c.status == common.Disconnected {
			return
		}
		log.Error().Err(err).Msgf("Error reading message from %s", c.RemoteAddr())
	}
	return
}=== internal/net/tcp_client.go ===
package net

import (
	"bufio"
	"net"
	"strings"

	"dmud/internal/common"
	"dmud/internal/game"

	"github.com/rs/zerolog/log"
)

type TCPClient struct {
	conn net.Conn
	game *game.Game
}

var _ common.Client = (*TCPClient)(nil)

func (c *TCPClient) CloseConnection() error {
	c.conn.Write([]byte("\nGoodbye!\n\n"))
	err := c.conn.Close()
	if err != nil {
		log.Error().Err(err).Msg("Error closing connection")
		return err
	}
	log.Printf("Closed connection to %s", c.RemoteAddr())
	return nil
}

func (c *TCPClient) HandleRequest() {
	g := c.game
	r := bufio.NewReader(c.conn)

	for {
		message, err := r.ReadString('\n')
		if err != nil {
			log.Error().Err(err).Msg("Error reading string from TCPClient")
			g.HandleDisconnect(c)
			return
		}

		message = strings.TrimSpace(message)

		log.Trace().Msgf("Received message from %s: %s", c.RemoteAddr(), message)

		parts := strings.SplitN(message, " ", 2)
		cmd := parts[0]
		var args []string
		if len(parts) > 1 {
			args = strings.Split(parts[1], " ")
		}

		command := game.Command{
			Cmd:  cmd,
			Args: args,
		}

		g.ExecuteCommandChan <- game.ClientCommand{Command: command, Client: c}
	}
}

func (c *TCPClient) RemoteAddr() string {
	return c.conn.RemoteAddr().String()
}

func (c *TCPClient) SendMessage(msg string) {
	_, err := c.conn.Write([]byte("\n" + msg + "\n\n"))
	if err != nil {
		log.Error().Err(err).Msg("Error sending message to TCPClient: %v")
	}
}
=== internal/systems/spawn.go ===
package systems

import (
	"dmud/internal/ecs"
)

type SpawnSystem struct{}

func (ms *SpawnSystem) Update(w *ecs.World, deltaTime float64) {

}
=== internal/systems/combat.go ===
package systems

import (
	"dmud/internal/common"
	"dmud/internal/components"
	"dmud/internal/ecs"
	"dmud/internal/util"
	"fmt"
	"math/rand"
	"time"

	"github.com/rs/zerolog/log"
)

type CombatSystem struct{}

func (cs *CombatSystem) Update(w *ecs.World, deltaTime float64) {
	attackingEntities, err := findAttackingEntities(w)
	if err != nil {
		log.Error().Msgf("Error finding attacking entities: %v", err)
		return
	}

	for _, attackingEntity := range attackingEntities {
		combat, err := getCombatComponent(w, attackingEntity.ID)
		if err != nil {
			log.Error().Msgf("Error getting attacker combat component: %v", err)
			return
		}

		if combat.TargetID == "" {
			return
		}

		attackingPlayer, err := getPlayerComponent(w, attackingEntity.ID)
		if err != nil {
			log.Error().Msgf("Error getting attacker player component: %v", err)
			return
		}

		targetPlayer, err := getPlayerComponent(w, combat.TargetID)
		if err != nil {
			log.Error().Msgf("Error getting target player component: %v", err)
			return
		}

		targetHealth, err := getHealthComponent(w, combat.TargetID)
		if err != nil {
			log.Error().Msgf("Error getting target health component: %v", err)
			return
		}

		if isTargetDead(targetHealth) {
			handleTargetDeath(w, attackingEntity.ID, combat.TargetID, attackingPlayer, targetPlayer)
			return
		}

		attackPlayer(attackingPlayer, targetPlayer, combat, targetHealth)
	}
}

func findAttackingEntities(w *ecs.World) ([]ecs.Entity, error) {
	return w.FindEntitiesByComponentPredicate("Combat", func(i interface{}) bool {
		return true
	})
}

func getCombatComponent(w *ecs.World, entityID common.EntityID) (*components.Combat, error) {
	return util.GetTypedComponent[components.Combat](w, entityID, "Combat")
}

func getPlayerComponent(w *ecs.World, entityID common.EntityID) (*components.Player, error) {
	return util.GetTypedComponent[components.Player](w, entityID, "Player")
}

func getHealthComponent(w *ecs.World, entityID common.EntityID) (*components.Health, error) {
	return util.GetTypedComponent[components.Health](w, entityID, "Health")
}

func isTargetDead(health *components.Health) bool {
	return health.Current <= 0
}

func handleTargetDeath(w *ecs.World, attackerID common.EntityID, targetID common.EntityID, attackerPlayer, targetPlayer *components.Player) {
	combat := &components.Combat{}
	combat.TargetID = ""

	w.RemoveComponent(attackerID, "Combat")
	w.RemoveComponent(targetID, "Combat")

	attackerPlayer.Broadcast(fmt.Sprintf("You killed %s!", targetPlayer.Name))
	targetPlayer.Broadcast("You have died!")
}

func attackPlayer(attackerPlayer, targetPlayer *components.Player, combat *components.Combat, targetHealth *components.Health) {
	s := rand.NewSource(time.Now().UnixNano())
	r := rand.New(s)

	damage := r.Intn(combat.MaxDamage-combat.MinDamage+1) + combat.MinDamage

	targetHealth.Lock()
	targetHealth.Current -= damage
	targetHealth.Unlock()

	attackerPlayer.Broadcast(fmt.Sprintf("You attacked %s for %d damage!", targetPlayer.Name, damage))
	targetPlayer.Broadcast(fmt.Sprintf("%s attacked you for %d damage!", attackerPlayer.Name, damage))

	log.Trace().Msg(fmt.Sprintf("%s attacked %s for %d damage!", attackerPlayer.Name, targetPlayer.Name, damage))
}
=== internal/systems/movement.go ===
package systems

import (
	"dmud/internal/components"
	"dmud/internal/ecs"
	"dmud/internal/util"

	"github.com/rs/zerolog/log"
)

type MovementSystem struct{}

func (ms *MovementSystem) Update(w *ecs.World, deltaTime float64) {
	movingEntities, err := w.FindEntitiesByComponentPredicate("Movement", func(i interface{}) bool {
		return true
	})
	if err != nil {
		return
	}

	for _, movingEntity := range movingEntities {
		HandleMovement(w, movingEntity)
	}
}

func HandleMovement(w *ecs.World, movingEntity ecs.Entity) {
	defer func() {
		w.RemoveComponent(movingEntity.ID, "Movement")
	}()

	movingPlayer, err := util.GetTypedComponent[components.Player](w, movingEntity.ID, "Player")
	if err != nil {
		log.Error().Msgf("Error getting moving player component: %v", err)
		return
	}

	playerHealth, err := util.GetTypedComponent[components.Health](w, movingEntity.ID, "Health")
	if err != nil {
		log.Error().Msgf("Error getting player health component: %v", err)
		return
	}

	if playerHealth.Status == components.Dead {
		movingPlayer.Broadcast("You are dead.")
		return
	}

	moving, err := util.GetTypedComponent[components.Movement](w, movingEntity.ID, "Movement")
	if err != nil {
		log.Error().Msgf("Error getting moving component: %v", err)
		return
	}

	if moving.Status == components.Standing {
		return
	}

	room := movingPlayer.Room
	if room == nil {
		log.Warn().Msgf("%v moving, but not in a room", movingPlayer)
		movingPlayer.Broadcast("Do you know where you are?")
		return
	}

	exit := room.GetExit(moving.Direction)
	if exit == nil {
		movingPlayer.Broadcast("You can't go that way.")
		return
	}

	room.RemovePlayer(movingPlayer)

	movingPlayer.Room = exit.Room
	movingPlayer.Room.AddPlayer(movingPlayer)
	movingPlayer.Broadcast(exit.Room.Description)
}
=== internal/util/slurs.go ===
package util

// List of slur words from Bluesky - https://github.com/bluesky-social/atproto
var Slurs = []string{
	"bluegum",
	"chink",
	"chinks",
	"coolie",
	"coolies",
	"coon",
	"coons",
	"coont",
	"golliwog",
	"golliwogs",
	"gook",
	"gooks",
	"gyp",
	"gyps",
	"half-breed",
	"halfbreed",
	"half-breeds",
	"halfbreeds",
	"heeb",
	"heebs",
	"hitler",
	"kaffer",
	"kaffers",
	"kaffir",
	"kaffirs",
	"kaffre",
	"kaffres",
	"kafir",
	"kafirs",
	"kike",
	"kikes",
	"kkk",
	"klukluxklan",
	"muzzie",
	"n1gga",
	"n1gger",
	"nazi ",
	"negorid",
	"negress",
	"nig",
	"nigg3r",
	"nigg4h",
	"nigga",
	"niggah",
	"niggas",
	"niggaz",
	"nigger",
	"niggerachi",
	"niggerette",
	"niggerican",
	"niggerino",
	"niggeroid",
	"niggers",
	"nigglet",
	"nigguh",
	"nigguhs",
	"nig-nog",
	"nig-nogs",
	"nigs",
	"paki",
	"pakis",
	"pedophile",
	"pickaninnie",
	"pickaninnies",
	"pickaninny",
	"pickaninnys",
	"raghead",
	"ragheads",
	"redskin",
	"sambo",
	"sambos",
	"spade",
	"spades",
	"spic",
	"spics",
	"squaw",
	"squaws",
	"wetback",
	"wetbacks",
	"yid",
	"yids",
}
=== internal/util/util.go ===
package util

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"math/rand"
	"runtime"
	"strconv"
	"strings"
	"time"
	"unicode"

	"dmud/internal/common"

	"github.com/rs/zerolog/log"
	"golang.org/x/crypto/bcrypt"
)

var lastTime time.Time

func init() {
	rand.Seed(time.Now().UnixNano())
}

type EntityID string

type WorldLike interface {
	GetComponent(entityID common.EntityID, componentName string) (interface{}, error)
}

func GetTypedComponent[T any](w WorldLike, entityID common.EntityID, componentName string) (*T, error) {
	componentUntyped, err := w.GetComponent(entityID, componentName)
	if err != nil {
		return nil, err
	}
	typedComponent, ok := componentUntyped.(T)
	if !ok {
		return nil, fmt.Errorf("failed to cast component %s to the expected type. Actual type: %T", componentName, componentUntyped)
	}
	return &typedComponent, nil
}

func CalculateDeltaTime() float64 {
	if lastTime.IsZero() {
		lastTime = time.Now()
		return 0
	}
	currentTime := time.Now()
	deltaTime := currentTime.Sub(lastTime).Seconds()
	lastTime = currentTime
	return deltaTime
}

func ContainsClient(clients []common.Client, client common.Client) bool {
	for _, c := range clients {
		if c == client {
			return true
		}
	}
	return false
}

func GenerateRandomName() string {
	noun := Nouns[rand.Intn(len(Nouns))]
	verb1 := AdjectiveVerbs1[rand.Intn(len(AdjectiveVerbs1))]
	verb2 := AdjectiveVerbs2[rand.Intn(len(AdjectiveVerbs2))]
	return fmt.Sprintf("%s-%s-%s", verb1, verb2, noun)
}

func GetGID() string {
	var buf [64]byte
	n := runtime.Stack(buf[:], false)
	idField := strings.Fields(strings.TrimPrefix(string(buf[:n]), "goroutine "))[0]
	id, err := strconv.ParseUint(idField, 10, 64)
	if err != nil {
		panic(fmt.Sprintf("cannot get goroutine id: %v", err))
	}
	return fmt.Sprintf("%d", id)
}

func HashAndSalt(pwd string) string {
	hash, err := bcrypt.GenerateFromPassword([]byte(pwd), bcrypt.MinCost)
	if err != nil {
		log.Error().Err(err).Msg("")
	}
	return string(hash)
}

func IsAlphaNumeric(str string) bool {
	for _, c := range str {
		if !unicode.IsLetter(c) && !unicode.IsNumber(c) {
			return false
		}
	}
	return true
}

func ParseJSON(filename string, v interface{}) error {
	data, err := ioutil.ReadFile(filename)
	if err != nil {
		return err
	}
	return json.Unmarshal(data, v)
}

// ..

var AdjectiveVerbs1 = []string{
	"vacuous",
	"cheerful",
	"harmonious",
	"sassy",
	"unsightly",
	"bearded",
	"irritating",
	"plastic",
	"defective",
	"cool",
	"standing",
	"frumpy",
	"perfect",
	"killing",
	"unnatural",
	"driving",
	"highfalutin",
	"wacky",
	"ghastly",
	"sneaking",
	"puffy",
	"humongous",
	"unbiased",
	"shanking",
	"ubiquitous",
	"magnificent",
	"scratchy",
	"wakeful",
	"minor",
	"broken",
	"elusive",
	"flaccid",
	"retro",
	"charging",
	"deeply",
	"dumb",
	"sordid",
	"godly",
	"ginormous",
	"deranged",
	"thin",
	"living",
	"upset",
	"hard",
	"stout",
	"mythic",
	"crappy",
	"wide",
	"profuse",
	"old",
	"hopeful",
	"somber",
	"ethereal",
	"handheld",
	"oval",
	"picayune",
	"squishy",
	"rubbery",
	"fair",
	"walking",
	"passionate",
	"fleshy",
	"precious",
	"stereotyped",
	"licking",
	"rude",
	"injuring",
	"congested",
	"aboriginal",
	"powerful",
	"apprehensive",
	"parched",
	"weak",
	"imported",
	"icky",
	"precocious",
	"hilarious",
	"sinewy",
	"rigid",
	"gullible",
	"ganking",
	"sweltering",
	"industrious",
	"unarmed",
	"trashy",
	"gleaming",
	"unequaled",
	"oily",
	"shallow",
	"speedhacking",
	"narrow",
	"helpless",
	"clever",
	"ragged",
	"tired",
	"yielding",
	"repeating",
	"jolly",
	"fanatical",
	"courageous",
	"curvy",
	"sandy",
	"obsolete",
	"nauseating",
	"momentous",
	"scarred",
	"womanly",
	"high",
	"huge",
	"flippant",
	"lumpy",
	"boring",
	"clean",
	"wet",
	"whimsical",
	"smashing",
	"fancy",
	"gloomy",
	"casual",
	"chunky",
	"woebegone",
	"obtainable",
	"ahead",
	"undesirable",
	"productive",
	"soggy",
	"solitary",
	"puzzled",
	"nonstop",
	"faint",
	"erratic",
	"foamy",
	"thirsty",
	"screeching",
	"aggro",
	"measly",
	"juicy",
	"clunky",
	"elegant",
	"puny",
	"vulgar",
	"bewildered",
	"sacred",
	"voiceless",
	"equable",
	"verdant",
	"hacking",
	"protective",
	"hardcore",
	"ragequitting",
	"strategic",
	"heavy",
	"loving",
	"armless",
	"soft",
	"red",
	"gastly",
	"excellent",
	"willing",
	"creepy",
	"anachronistic",
	"strafing",
	"disturbed",
	"crazy",
	"mean",
	"fragrant",
	"futuristic",
	"great",
	"painful",
	"infinite",
	"chewing",
	"crafting",
	"hurried",
	"slender",
	"crumpled",
	"panting",
	"jagged",
	"warm",
	"odd",
	"permissible",
	"feeding",
	"tenuous",
	"poking",
	"belligerent",
	"imminent",
	"shaky",
	"hungry",
	"unhealthy",
	"ordinary",
	"disgusting",
	"shouting",
	"vivacious",
	"stalking",
	"fighting",
	"relieved",
	"depressed",
	"filthy",
	"raw",
	"withered",
	"sudden",
	"slippery",
	"orange",
	"eminent",
	"cooperative",
	"magenta",
	"robust",
	"encouraging",
	"expanding",
	"abhorrent",
	"soiled",
	"waggish",
	"divergent",
	"pickpocketing",
	"spicy",
	"chubby",
	"flaky",
	"camping",
	"tracking",
	"interesting",
	"intelligent",
	"premium",
	"honorable",
	"fierce",
	"savage",
	"feral",
	"imperfect",
	"inconclusive",
	"amazing",
	"grouping",
	"wretched",
	"lean",
	"optimal",
	"slow",
	"tiny",
	"parsimonious",
	"yummy",
	"confused",
	"exotic",
	"learning",
	"dying",
	"panoramic",
	"elated",
	"blind",
	"impartial",
	"glowing",
	"evil",
	"monstrous",
	"gutsy",
	"cunning",
	"concerned",
	"indie",
	"common",
	"tame",
	"aberrant",
	"assisting",
	"addictive",
}
var AdjectiveVerbs2 = []string{
	"threatening",
	"handsomely",
	"raiding",
	"charred",
	"splendid",
	"hairy",
	"tested",
	"dashing",
	"turgid",
	"jumbled",
	"interactive",
	"elder",
	"sedate",
	"blue",
	"colossal",
	"friendly",
	"shiny",
	"sloppy",
	"dysfunctional",
	"suffering",
	"endurable",
	"joyous",
	"fragging",
	"flat",
	"dapper",
	"bloody",
	"aloof",
	"fetid",
	"stiff",
	"fragile",
	"lame",
	"goofy",
	"abounding",
	"passive",
	"spawning",
	"tackling",
	"innocent",
	"glamorous",
	"inexpensive",
	"intense",
	"spiritual",
	"flashy",
	"mutant",
	"miscreant",
	"fabulous",
	"targeting",
	"swimming",
	"purple",
	"bald",
	"irate",
	"irradiated",
	"crabby",
	"beautiful",
	"tangy",
	"vast",
	"learned",
	"punching",
	"farming",
	"buff",
	"late",
	"neighborly",
	"cowardly",
	"putrid",
	"good",
	"judicious",
	"geeky",
	"wistful",
	"square",
	"torpid",
	"stuffy",
	"stinky",
	"delicious",
	"healing",
	"powerleveling",
	"brave",
	"skinny",
	"rookie",
	"lazy",
	"short",
	"sweet",
	"lively",
	"boundless",
	"stingy",
	"flawless",
	"overwrought",
	"enchanted",
	"bashful",
	"pretty",
	"groping",
	"drunk",
	"furry",
	"volatile",
	"glistening",
	"heady",
	"vigorous",
	"level",
	"offline",
	"quirky",
	"romantic",
	"clumsy",
	"feeble",
	"haunting",
	"miniscule",
	"backstabbing",
	"master",
	"lewd",
	"calm",
	"gaudy",
	"tactical",
	"wrong",
	"kicking",
	"swampy",
	"jogging",
	"watery",
	"vengeful",
	"cloistered",
	"looting",
	"dripping",
	"automatic",
	"disagreeable",
	"stale",
	"scared",
	"husky",
	"cheating",
	"dispensable",
	"dirty",
	"stupid",
	"rare",
	"lascivious",
	"busy",
	"sad",
	"supreme",
	"chatting",
	"psychotic",
	"whispering",
	"polite",
	"gorgeous",
	"ruthless",
	"throwing",
	"obese",
	"unsuitable",
	"marked",
	"acceptable",
	"repulsive",
	"stimulating",
	"quick",
	"manly",
	"pleasing",
	"aspiring",
	"lubricated",
	"miniature",
	"shining",
	"cloudy",
	"curly",
	"nostalgic",
	"terrible",
	"exploiting",
	"murky",
	"angry",
	"howling",
	"proud",
	"talking",
	"tacky",
	"laughable",
	"green",
	"professional",
	"historical",
	"scary",
	"holy",
	"questing",
	"tightfisted",
	"mad",
	"sucky",
	"sleepy",
	"exclusive",
	"quiet",
	"squeamish",
	"rotund",
	"ritzy",
	"trite",
	"light",
	"silly",
	"natural",
	"cold",
	"faulty",
	"poor",
	"invincible",
	"grinding",
	"skateboarding",
	"questionable",
	"yelling",
	"classy",
	"obedient",
	"exuberant",
	"faithful",
	"gangrenous",
	"labored",
	"ambiguous",
	"itchy",
	"rambunctious",
	"flying",
	"pleasant",
	"meek",
	"little",
	"nerdy",
	"average",
	"arrogant",
	"kind",
	"pathetic",
	"synonymous",
	"bright",
	"indifferent",
	"crusty",
	"determined",
	"modding",
	"sweaty",
	"organic",
	"charming",
	"hostile",
	"kindhearted",
	"witty",
	"elite",
	"jazzy",
	"trusting",
	"succulent",
	"mourning",
	"venomous",
	"nasty",
	"long",
	"placid",
	"capricious",
	"tender",
	"phobic",
	"dubious",
	"known",
	"hitting",
	"abrasive",
	"sultry",
	"maniacal",
	"ceaseless",
	"annoyed",
	"sprinting",
	"typical",
	"deserted",
	"cynical",
	"ancient",
	"acidic",
	"fast",
	"melodic",
	"jumping",
	"shaggy",
	"leveling",
	"glitching",
	"pointless",
	"greasy",
	"chilly",
}
var Nouns = []string{
	"abomination",
	"agent",
	"alien",
	"alucard",
	"android",
	"arachnid",
	"archdemon",
	"archer",
	"archlich",
	"archmage",
	"archon",
	"bouncer",
	"asari",
	"assassin",
	"barbarian",
	"bard",
	"bat",
	"beaver",
	"angel",
	"lonin",
	"beast",
	"lord",
	"begger",
	"berserker",
	"birdperson",
	"blacksmith",
	"boar",
	"archduke",
	"sailor",
	"bugbear",
	"veteran",
	"wyrm",
	"captain",
	"centaur",
	"champion",
	"king",
	"queen",
	"cheater",
	"chicken",
	"outcast",
	"conjurer",
	"cleric",
	"cockatrice",
	"colossus",
	"creature",
	"creeper",
	"critter",
	"crusader",
	"cultist",
	"cyborg",
	"dancer",
	"adult",
	"baboon",
	"demon",
	"diety",
	"adventurer",
	"dinosaur",
	"disciple",
	"djinn",
	"acolyte",
	"dragon",
	"dragonkin",
	"dragoon",
	"drake",
	"hoplite",
	"droid",
	"drow",
	"druid",
	"dwarf",
	"elemental",
	"elf",
	"enchanter",
	"bug",
	"engineer",
	"sphinx",
	"cow",
	"faerie",
	"froglok",
	"gamer",
	"frst",
	"tyrant",
	"ghost",
	"ghoul",
	"changeling",
	"gnoll",
	"gnome",
	"goat",
	"goblin",
	"golem",
	"grandmaster",
	"gremlin",
	"griffon",
	"grunt",
	"guardian",
	"gunner",
	"cyclops",
	"hacker",
	"halfling",
	"hippogriff",
	"hobbit",
	"hobgoblin",
	"hobo",
	"human",
	"hunter",
	"fairy",
	"juggernaut",
	"owl",
	"imp",
	"inquisitor",
	"scout",
	"dustywusty",
	"joker",
	"jester",
	"justicar",
	"hipster",
	"chief",
	"knight",
	"kobold",
	"harpy",
	"kraken",
	"emcl",
	"leader",
	"lemming",
	"leviathan",
	"lich",
	"link",
	"lizardman",
	"camel",
	"mage",
	"magus",
	"marine",
	"viper",
	"marksman",
	"mech",
	"member",
	"merchant",
	"minion",
	"mirelurk",
	"mongrel",
	"monk",
	"monster",
	"ape",
	"banshee",
	"badger",
	"devil",
	"mushroom",
	"mystic",
	"neckbeard",
	"necromancer",
	"ninja",
	"nymph",
	"ogre",
	"ooze",
	"oracle",
	"orc",
	"ork",
	"owlbear",
	"paladin",
	"panda",
	"paragon",
	"steed",
	"pawn",
	"bear",
	"penguin",
	"pet",
	"cube",
	"mastermind",
	"pirate",
	"predator",
	"priest",
	"yeti",
	"construct",
	"cat",
	"pyromancer",
	"dog",
	"ranger",
	"raptor",
	"rat",
	"avatar",
	"reaver",
	"robot",
	"rogue",
	"hound",
	"samurai",
	"celestial",
	"satyr",
	"scion",
	"scorpion",
	"seer",
	"phoenix",
	"shade",
	"shadowknight",
	"shaman",
	"shieldbearer",
	"wretch",
	"shopkeeper",
	"mummy",
	"skeleton",
	"slime",
	"crow",
	"smuggler",
	"snake",
	"sniper",
	"soldier",
	"sanic",
	"sorcerer",
	"specter",
	"spider",
	"spy",
	"fiend",
	"hag",
	"succubus",
	"summoner",
	"chimera",
	"synth",
	"gladiator",
	"commoner",
	"templar",
	"aberration",
	"titan",
	"toad",
	"treant",
	"troglodyte",
	"troll",
	"trooper",
	"undead",
	"vampire",
	"villager",
	"mouse",
	"turtle",
	"warg",
	"gunslinger",
	"warlock",
	"warlord",
	"warrior",
	"werewolf",
	"whale",
	"wisp",
	"witch",
	"witchdoctor",
	"wizard",
	"wolf",
	"wolverine",
	"alchemist",
	"tentacle",
	"wraith",
	"wurm",
	"wyvern",
	"watchman",
	"monstrosity",
	"crocodile",
	"crab",
	"dryad",
	"zerg",
	"zombie",
	"baron",
}
=== internal/util/messages.go ===
package util

const (
	WelcomeBanner = `
  ▄████  ██▀███   ██▓ ███▄ ▄███▓   ▓█████  ▄████▄   ██░ ██  ▒█████  ▓█████   ██████ 
 ██▒ ▀█▒▓██ ▒ ██▒▓██▒▓██▒▀█▀ ██▒   ▓█   ▀ ▒██▀ ▀█  ▓██░ ██▒▒██▒  ██▒▓█   ▀ ▒██    ▒ 
▒██░▄▄▄░▓██ ░▄█ ▒▒██▒▓██    ▓██░   ▒███   ▒▓█    ▄ ▒██▀▀██░▒██░  ██▒▒███   ░ ▓██▄   
░▓█  ██▓▒██▀▀█▄  ░██░▒██    ▒██    ▒▓█  ▄ ▒▓▓▄ ▄██▒░▓█ ░██ ▒██   ██░▒▓█  ▄   ▒   ██▒
░▒▓███▀▒░██▓ ▒██▒░██░▒██▒   ░██▒   ░▒████▒▒ ▓███▀ ░░▓█▒░██▓░ ████▓▒░░▒████▒▒██████▒▒
 ░▒   ▒ ░ ▒▓ ░▒▓░░▓  ░ ▒░   ░  ░   ░░ ▒░ ░░ ░▒ ▒  ░ ▒ ░░▒░▒░ ▒░▒░▒░ ░░ ▒░ ░▒ ▒▓▒ ▒ ░
  ░   ░   ░▒ ░ ▒░ ▒ ░░  ░      ░    ░ ░  ░  ░  ▒    ▒ ░▒░ ░  ░ ▒ ▒░  ░ ░  ░░ ░▒  ░ ░
░ ░   ░   ░░   ░  ▒ ░░      ░         ░   ░         ░  ░░ ░░ ░ ░ ▒     ░   ░  ░  ░  
      ░    ░      ░         ░         ░  ░░ ░       ░  ░  ░    ░ ░     ░  ░      ░  
                                          ░                                         
`
)
=== internal/components/spawn.go ===
package components

type SpawnType int

const (
	SpawnTypeNPC SpawnType = iota
	SpawnTypePlayer
)

type SpawnTable interface {
	MaxCount() int
	MinCount() int
	SpawnType()
}

type Spawn interface {
	GetSpawn(SpawnType) Spawn
	AddSpawn(SpawnType, Spawn) error
	RemoveSpawn(SpawnType) error
	ListSpawns() []SpawnTable
}
=== internal/components/health.go ===
package components

import "sync"

type HealthStatus int

const (
	Healthy HealthStatus = iota
	Injured
	Dead
)

type Health struct {
	sync.RWMutex

	Current int
	Max     int
	Status  HealthStatus
}

func (hc *Health) Heal(amount int) {
	hc.Current += amount
	if hc.Current > hc.Max {
		hc.Current = hc.Max
		hc.Status = Healthy
	}
}

func (hc *Health) TakeDamage(amount int) {
	hc.Current -= amount
	if hc.Current < 1 {
		hc.Current = 0
		hc.Status = Dead
	} else {
		hc.Status = Injured
	}
}
=== internal/components/player.go ===
package components

import (
	"dmud/internal/common"
	"sync"
)

type Player struct {
	sync.RWMutex

	Client common.Client

	Name string
	Room *Room
}

func (p *Player) Broadcast(m string) {
	p.Client.SendMessage(m)
}

func (p *Player) Look() {
	p.Broadcast(p.Room.Description)
}
=== internal/components/combat.go ===
package components

import (
	"dmud/internal/common"
	"sync"
)

type Combat struct {
	sync.RWMutex

	TargetID  common.EntityID
	MinDamage int
	MaxDamage int
}
=== internal/components/movement.go ===
package components

import "sync"

type MovementStatus int

const (
	Standing MovementStatus = iota
	Down
	Walking
	Running
)

type Movement struct {
	sync.RWMutex

	Status    MovementStatus
	Direction string
}
=== internal/components/npc.go ===
package components

import (
	"sync"
)

type NPC struct {
	sync.RWMutex

	Name string
	Room *Room
}
=== internal/components/room.go ===
package components

import (
	"sync"

	"github.com/rs/zerolog/log"
)

type Exit struct {
	Direction string
	RoomID    string
	Room      *Room
}

type Room struct {
	sync.RWMutex

	X int
	Y int
	Z int

	Description string
	Exits       []Exit
	Players     []*Player

	PlayersMutex sync.RWMutex
}

func (r *Room) AddPlayer(p *Player) {
	log.Info().Msgf("Player added to room: %s", p.Name)

	r.Broadcast(p.Name + " enters")

	r.PlayersMutex.Lock()
	r.Players = append(r.Players, p)
	r.PlayersMutex.Unlock()
}

func (r *Room) GetExit(direction string) *Exit {
	for _, exit := range r.Exits {
		if exit.Direction == direction {
			return &exit
		}
	}
	return nil
}

func (r *Room) GetPlayer(name string) *Player {
	r.PlayersMutex.Lock()
	for _, player := range r.Players {
		if player.Name == name {
			r.PlayersMutex.Unlock()
			return player
		}
	}
	r.PlayersMutex.Unlock()
	return nil
}

func (r *Room) Broadcast(msg string, exclude ...*Player) {
	r.PlayersMutex.Lock()
	defer r.PlayersMutex.Unlock()

	if len(r.Players) == 0 {
		return
	}

	for _, player := range r.Players {
		if !contains(exclude, player) {
			player.Broadcast(msg)
		}
	}
}

func (r *Room) RemovePlayer(p *Player) {
	r.PlayersMutex.Lock()
	for i, player := range r.Players {
		if player == p {
			r.Players = append(r.Players[:i], r.Players[i+1:]...)
			break
		}
	}
	r.PlayersMutex.Unlock()
	r.Broadcast(p.Name + " leaves")
}

// ..

func contains(players []*Player, player *Player) bool {
	for _, p := range players {
		if p == player {
			return true
		}
	}
	return false
}
=== internal/game/game.go ===
package game

import (
	"fmt"
	"strings"
	"sync"
	"time"

	"dmud/internal/common"
	"dmud/internal/components"
	"dmud/internal/ecs"
	"dmud/internal/systems"
	"dmud/internal/util"

	"github.com/jedib0t/go-pretty/table"
	"github.com/rs/zerolog/log"
)

type Game struct {
	defaultRoom *components.Room

	players   map[string]*ecs.Entity
	playersMu sync.Mutex

	world *ecs.World

	AddPlayerChan      chan common.Client
	RemovePlayerChan   chan common.Client
	ExecuteCommandChan chan ClientCommand
}

func (g *Game) HandleConnect(c common.Client) {
	playerComponent := &components.Player{
		Client: c,
		Name:   util.GenerateRandomName(),
		Room:   g.defaultRoom,
	}
	healthComponent := &components.Health{
		Max:     100,
		Current: 100,
	}

	playerEntity := ecs.NewEntity()
	g.world.AddEntity(playerEntity)

	g.world.AddComponent(&playerEntity, playerComponent)
	g.world.AddComponent(&playerEntity, healthComponent)

	g.playersMu.Lock()

	g.players[playerComponent.Name] = &playerEntity
	g.defaultRoom.AddPlayer(playerComponent)

	g.playersMu.Unlock()

	playerComponent.Broadcast(util.WelcomeBanner)
	playerComponent.Broadcast(g.defaultRoom.Description)

	g.Broadcast(fmt.Sprintf("%s has joined the game.", playerComponent.Name), c)

	go c.HandleRequest()
}

func (g *Game) HandleDisconnect(c common.Client) {
	player, err := g.getPlayer(c)
	if err != nil {
		return
	}

	g.playersMu.Lock()

	var playerEntity = g.players[player.Name]
	if playerEntity == nil {
		log.Error().Msg("Player entity was nil")
		return
	}

	g.world.RemoveEntity(playerEntity.ID)

	log.Trace().Msgf("Number of players: %d", len(g.players))
	delete(g.players, player.Name)
	log.Trace().Msgf("Number of players: %d", len(g.players))

	g.playersMu.Unlock()
	c.CloseConnection()

	g.Broadcast(fmt.Sprintf("%s has left the game.", player.Name), c)
}

func (g *Game) getPlayer(c common.Client) (*components.Player, error) {
	g.playersMu.Lock()
	defer g.playersMu.Unlock()

	for _, playerEntity := range g.players {
		playerComponent, err := g.world.GetComponent(playerEntity.ID, "Player")
		if err != nil {
			return nil, fmt.Errorf("error getting player component for entity id %s, %v", playerEntity.ID, err)
		}

		player, ok := playerComponent.(*components.Player)
		if !ok {
			return nil, fmt.Errorf("unable to cast component to Player")
		}

		if player.Client == c {
			return player, nil
		}
	}
	return nil, fmt.Errorf("player not found")
}

func (g *Game) handleCommand(c ClientCommand) {
	command := c.Command
	client := c.Client

	player, err := g.getPlayer(client)
	if err != nil {
		log.Warn().Msg(fmt.Sprintf("Error getting player component: %s", err))
		return
	}

	switch c.Command.Cmd {
	case "exit":
		g.handleExit(player, command)
	case "k", "kill":
		g.handleKill(player, command)
	case "look":
		player.Look()
	case "n", "s", "e", "w", "u", "d", "north", "south", "east", "west", "up", "down":
		g.handleMove(player, command)
	case "name":
		g.handleRename(player, command)
	case "say":
		g.handleSay(player, command)
	case "scan":
		g.handleScan(player, command)
	case "shout":
		g.handleShout(player, strings.Join(command.Args, " "))
	case "who":
		g.handleWho(player, command)
	default:
		player.Broadcast(fmt.Sprintf("What do you mean, \"%s\"?", command.Cmd))
	}
}

func (g *Game) handleExit(player *components.Player, command Command) {
	player.RWMutex.RLock()
	defer player.RWMutex.RUnlock()

	g.HandleDisconnect(player.Client)
}

func (g *Game) handleLook(player *components.Player, command Command) {
	player.RWMutex.RLock()
	defer player.RWMutex.RUnlock()

	player.Look()
}

func (g *Game) handleMove(player *components.Player, command Command) {
	dirMapping := map[string]string{
		"n": "north",
		"s": "south",
		"e": "east",
		"w": "west",
		"u": "up",
		"d": "down",
	}

	fullDir := command.Cmd
	if shortDir, ok := dirMapping[command.Cmd]; ok {
		fullDir = shortDir
	}

	player.RWMutex.RLock()
	playerEntity := g.players[player.Name]
	player.RWMutex.RUnlock()

	if playerEntity == nil {
		log.Warn().Msg(fmt.Sprintf("Error getting player's own entity for %s", player.Name))
		return
	}

	movement := components.Movement{
		Direction: fullDir,
		Status:    components.Walking,
	}
	g.world.AddComponent(playerEntity, &movement)
}

func (g *Game) handleRename(player *components.Player, command Command) {
	player.Lock()
	defer player.Unlock()

	if (len(command.Args) == 0) || (len(command.Args) > 1) {
		player.Broadcast(player.Name)
		return
	}

	newName := command.Args[0]
	oldName := player.Name

	player.Name = newName
	g.players[newName] = g.players[oldName]
	delete(g.players, oldName)

	g.Broadcast(fmt.Sprintf("%s has changed their name to %s", oldName, player.Name))
}

func (g *Game) handleSay(player *components.Player, command Command) {
	player.RWMutex.RLock()
	defer player.RWMutex.RUnlock()

	msg := strings.Join(command.Args, " ")
	if msg == "" {
		player.Broadcast("Say what?")
		return
	}

	player.Room.Broadcast(fmt.Sprintf("%s says: %s", player.Name, msg))
}

func (g *Game) handleScan(player *components.Player, command Command) {
	player.RWMutex.RLock()
	defer player.RWMutex.RUnlock()

	exits := []string{}
	for _, exit := range player.Room.Exits {
		exits = append(exits, exit.Direction)
	}

	player.Broadcast("Exits: " + strings.Join(exits, ", "))
}

func (g *Game) handleShout(player *components.Player, msg string, depths ...int) {
	player.RWMutex.RLock()
	defer player.RWMutex.RUnlock()

	if player.Room == nil {
		player.Broadcast("You shout but there is no sound")
		return
	}
	log.Info().Msgf("Shout: %s", msg)

	depth := 10
	if len(depths) > 0 {
		depth = depths[0]
	}

	visited := make(map[*components.Room]bool)
	queue := []*components.Room{player.Room}

	for depth > 0 && len(queue) > 0 {
		depth--
		nextQueue := []*components.Room{}

		for _, room := range queue {
			visited[room] = true
			for _, exit := range room.Exits {
				if !visited[exit.Room] {
					visited[exit.Room] = true
					nextQueue = append(nextQueue, exit.Room)
				}
			}
		}
		queue = nextQueue
	}

	for room := range visited {
		room.Broadcast(player.Name+" shouts: "+msg, player)
	}
}

func (g *Game) handleWho(player *components.Player, command Command) {
	g.playersMu.Lock()
	defer g.playersMu.Unlock()

	tw := table.NewWriter()
	tw.SetStyle(table.StyleLight)
	tw.AppendHeader(table.Row{"Player", "Race", "Class", "Online Since"})

	for _, playerEntity := range g.players {
		playerComponent, err := g.world.GetComponent(playerEntity.ID, "Player")
		if err != nil {
			log.Error().Err(err).Msgf("Could not get component for player %s", playerEntity.ID)
			continue
		}
		player, ok := playerComponent.(*components.Player)
		if !ok {
			log.Error().Msgf("Error type asserting component for player %s", playerEntity.ID)
			continue
		}
		tw.AppendRow(table.Row{player.Name, "??", "??", playerEntity.CreatedAt.DiffForHumans()})
	}

	player.Broadcast(tw.Render())
}

func (g *Game) handleKill(player *components.Player, command Command) {
	log.Trace().Msgf("Kill: %s", command.Args)

	targetEntity := g.players[strings.Join(command.Args, " ")]
	if targetEntity == nil {
		player.Broadcast("Kill who?")
		return
	}

	g.playersMu.Lock()
	playerEntity := g.players[player.Name]
	g.playersMu.Unlock()

	if playerEntity == nil {
		log.Warn().Msg(fmt.Sprintf("Error getting player's own entity for %s", player.Name))
		return
	}

	attackingPlayer := components.Combat{
		TargetID:  targetEntity.ID,
		MinDamage: 10,
		MaxDamage: 50,
	}

	g.world.AddComponent(playerEntity, &attackingPlayer)
}

func (g *Game) loop() {
	updateTicker := time.NewTicker(10 * time.Millisecond)
	defer updateTicker.Stop()

	for {
		select {
		case client := <-g.AddPlayerChan:
			g.HandleConnect(client)
		case client := <-g.RemovePlayerChan:
			g.HandleDisconnect(client)
		case command := <-g.ExecuteCommandChan:
			g.handleCommand(command)
		case <-updateTicker.C:
			g.world.Update()
		}
	}
}

func (g *Game) Broadcast(m string, excludeClients ...common.Client) {
	log.Info().Msgf("Broadcasting: %s", m)

	for _, playerEntity := range g.players {
		playerComponent, err := g.world.GetComponent(playerEntity.ID, "Player")
		if err != nil {
			log.Error().Msgf("error getting player for entity id %s, %v", playerEntity.ID, err)
			continue
		}

		player, ok := playerComponent.(*components.Player)
		if !ok {
			log.Error().Msgf("unable to cast component to Player %v", playerComponent)
			continue
		}

		if !util.ContainsClient(excludeClients, player.Client) {
			player.Broadcast(m)
		}
	}
}

func NewGame() *Game {
	combatSystem := &systems.CombatSystem{}
	movementSystem := &systems.MovementSystem{}

	world := ecs.NewWorld()
	world.AddSystem(combatSystem)
	world.AddSystem(movementSystem)

	defaultRoom, _ := world.GetComponent("1", "Room")

	game := Game{
		defaultRoom:        defaultRoom.(*components.Room),
		players:            make(map[string]*ecs.Entity),
		world:              world,
		AddPlayerChan:      make(chan common.Client),
		RemovePlayerChan:   make(chan common.Client),
		ExecuteCommandChan: make(chan ClientCommand),
	}

	go game.loop()

	return &game
}
=== internal/game/command.go ===
package game

import "dmud/internal/common"

type ClientCommand struct {
	Client  common.Client
	Command Command
}

type Command struct {
	Cmd  string
	Args []string
}
=== internal/ecs/component.go ===
package ecs

type Component interface {
}
=== internal/ecs/world.go ===
package ecs

import (
	"fmt"
	"reflect"
	"sync"

	"dmud/internal/common"
	"dmud/internal/components"
	"dmud/internal/util"

	"github.com/rs/zerolog/log"
)

type World struct {
	components     map[common.EntityID]map[string]Component
	componentMutex sync.RWMutex

	entities    map[common.EntityID]Entity
	entityMutex sync.RWMutex

	elapsedTime float64

	systems []System
}

func (w *World) AddComponent(entity *Entity, component Component) {
	w.componentMutex.Lock()
	defer w.componentMutex.Unlock()

	w.entityMutex.Lock()
	defer w.entityMutex.Unlock()

	componentName := reflect.TypeOf(component).Elem().Name()
	if _, ok := w.components[entity.ID]; ok {
		w.components[entity.ID][componentName] = component
	} else {
		w.components[entity.ID] = make(map[string]Component)
		w.components[entity.ID][componentName] = component
	}

	entity.Components[componentName] = true

	log.Info().Msgf("Added component %s to entity %s", componentName, entity.ID)
}

func (w *World) AddEntity(entity Entity) {
	w.entityMutex.Lock()
	defer w.entityMutex.Unlock()

	w.componentMutex.Lock()
	defer w.componentMutex.Unlock()

	w.entities[entity.ID] = entity
	w.components[entity.ID] = make(map[string]Component)

	log.Info().Msgf("Added entity %s", entity.ID)
}

func (w *World) AddSystem(system System) {
	w.systems = append(w.systems, system)
}

func (w *World) Components() map[common.EntityID]map[string]Component {
	w.entityMutex.RLock()
	defer w.entityMutex.RUnlock()

	return w.components
}

func (w *World) Entities() map[common.EntityID]Entity {
	w.entityMutex.RLock()
	defer w.entityMutex.RUnlock()

	return w.entities
}

func (w *World) FindEntity(id common.EntityID) (Entity, error) {
	w.entityMutex.RLock()
	defer w.entityMutex.RUnlock()

	entity, ok := w.entities[id]

	if !ok {
		return Entity{}, nil
	}

	return entity, nil
}

func (w *World) FindEntitiesByComponentPredicate(componentType string, predicate func(interface{}) bool) ([]util.EntityLike, error) {
	w.componentMutex.RLock()
	defer w.componentMutex.RUnlock()

	w.entityMutex.RLock()
	defer w.entityMutex.RUnlock()

	entities := make([]Entity, 0)
	for entityID, components := range w.components {
		component, ok := components[componentType]
		if ok && predicate(component) {
			if entity, exists := w.entities[entityID]; exists {
				entities = append(entities, entity)
			}
		}
	}

	if len(entities) == 0 {
		return nil, nil
	}

	return entities, nil
}

func (w *World) GetComponent(entityID common.EntityID, componentName string) (interface{}, error) {
	w.componentMutex.RLock()
	defer w.componentMutex.RUnlock()

	if components, ok := w.components[entityID]; ok {
		if component, ok := components[componentName]; ok {
			return component, nil
		}
		return nil, fmt.Errorf("component %s not found for entity %s", componentName, entityID)
	}

	return nil, fmt.Errorf("entity %s not found", entityID)
}

func (w *World) RemoveComponent(entityID common.EntityID, componentName string) {
	w.componentMutex.Lock()
	defer w.componentMutex.Unlock()

	if _, ok := w.components[entityID]; ok {
		delete(w.components[entityID], componentName)
		if len(w.components[entityID]) == 0 {
			delete(w.components, entityID)
		}
	} else {
		log.Error().Msgf("Entity %s does not have component %s", entityID, componentName)
	}

	log.Info().Msgf("Removed component %s from entity %s", componentName, entityID)
}

func (w *World) RemoveEntity(entityID common.EntityID) {
	if playerComponent, err := w.GetComponent(entityID, "Player"); err == nil {
		player, ok := playerComponent.(*components.Player)
		if !ok {
			log.Error().Msgf("Error type asserting Player for player %s", entityID)
		} else {
			if player.Room != nil {
				player.Room.RemovePlayer(player)
			}
		}
	}

	w.entityMutex.Lock()
	delete(w.entities, entityID)
	w.entityMutex.Unlock()

	w.componentMutex.Lock()
	delete(w.components, entityID)
	w.componentMutex.Unlock()

	log.Info().Msgf("Removed entity %s", entityID)
}

func (w *World) Update() {
	deltaTime := util.CalculateDeltaTime()

	w.elapsedTime += deltaTime

	if w.elapsedTime >= 0.1 {
		for _, system := range w.systems {
			system.Update(w, deltaTime)
		}

		w.elapsedTime = 0
	}
}

func NewWorld() *World {
	world := &World{
		entities:   make(map[common.EntityID]Entity),
		components: make(map[common.EntityID]map[string]Component),
	}

	rooms := loadRoomsFromFile("./resources/rooms.json")

	for _, room := range rooms {
		roomEntity := NewEntity(room.ID)
		roomComponent := &components.Room{
			Description: room.Description,
		}
		world.AddEntity(roomEntity)
		world.AddComponent(&roomEntity, roomComponent)
	}

	for _, room := range rooms {
		component, err := world.GetComponent(common.EntityID(room.ID), "Room")
		if err != nil {
			log.Error().Err(err).Msgf("Could not get Room for room %s", room.ID)
			continue
		}

		roomComponent, ok := component.(*components.Room)
		if !ok {
			log.Error().Msgf("Error type asserting Room for room %s", room.ID)
			continue
		}

		for direction, roomID := range room.Exits {
			exitRoomUntyped, err := world.GetComponent(common.EntityID(roomID), "Room")
			if err != nil {
				log.Error().Err(err).Msgf("Could not get Room for exit room %s", roomID)
				continue
			}

			exitRoom, ok := exitRoomUntyped.(*components.Room)
			if !ok {
				log.Error().Msgf("Error type asserting Room for exit room %s", roomID)
				continue
			}

			roomComponent.Exits = append(roomComponent.Exits, components.Exit{
				Direction: direction,
				RoomID:    roomID,
				Room:      exitRoom,
			})
		}
	}

	return world
}

type Room struct {
	ID          string            `json:"id"`
	Description string            `json:"description"`
	Exits       map[string]string `json:"exits"`
}

func loadRoomsFromFile(filename string) []Room {
	var rooms []Room
	if err := util.ParseJSON(filename, &rooms); err != nil {
		log.Error().Err(err).Msg("")
	}
	return rooms
}
=== internal/ecs/system.go ===
package ecs

type System interface {
	Update(world *World, deltaTime float64)
}
=== internal/ecs/entity.go ===
package ecs

import (
	"dmud/internal/common"

	"github.com/golang-module/carbon/v2"
	"github.com/google/uuid"
	"github.com/rs/zerolog/log"
)

type Entity struct {
	Components map[string]bool
	CreatedAt  carbon.Carbon
	ID         common.EntityID
	UpdatedAt  carbon.Carbon
}

func NewEntity(ids ...string) Entity {
	var id string

	if len(ids) > 0 {
		id = ids[0]
	} else {
		_uuid := uuid.New()
		id = _uuid.String()
	}

	log.Info().Msgf("Created entity %v", id)

	return Entity{
		ID:         common.EntityID(id),
		Components: make(map[string]bool),
		CreatedAt:  carbon.Now(),
		UpdatedAt:  carbon.Now(),
	}
}

func (e Entity) String() string {
	return string(e.ID)
}
=== internal/common/client.go ===
package common

type ClientType int

const (
	TCP ClientType = iota
	WebSocket
)

type ConnectionStatus string

const (
	Connecting    ConnectionStatus = "connecting"
	Connected     ConnectionStatus = "connected"
	Disconnecting ConnectionStatus = "disconnecting"
	Disconnected  ConnectionStatus = "disconnected"
)

type Client interface {
	CloseConnection() error
	HandleRequest()
	SendMessage(msg string)
	RemoteAddr() string
}
=== internal/common/entity.go ===
package common

type EntityID string
